#!/bin/bash
##
# Terminator: backup and maintenance system for servers
# Copyright 2016 Tim Kennell Jr.
# Licensed under the MIT License (http://opensource.org/licenses/MIT)
##

# ------------ #
# System Check #
# ------------ #

# Create log directory if not exists
if ! [[ -d log ]] ; then
	mkdir log
fi

# Set up log file
log_file=log/$HOSTNAME.$(date +"%F_%R").log
touch "$log_file"

# Check for terminator.conf file
if ! [[ -f terminator.conf ]] ; then
	echo "# System check" >> "$log_file"
	echo "E: could not find 'terminator.conf'.  Please run 'setup'" >> \
		"$log_file"

	exit 1
fi

# Load in user configurations
. ./terminator.conf

error_flag=0
email_body="List of errors during system maintenance\n"


# ----------------- #
# Automagic Updates #
# ----------------- #

# Update
# echo "updating"
echo "# aptitude update" >> "$log_file"
aptitude update &>> "$log_file"
echo >> "$log_file"

# Upgrade
# echo "upgrading"
echo "# aptitude full-upgrade" >> "$log_file"
aptitude -y full-upgrade &>> "$log_file"
echo >> "$log_file"

# Clean
# echo "cleaning"
echo "# aptitude clean" >> "$log_file"
aptitude -y clean &>> "$log_file"
echo >> "$log_file"

# If errors with update and upgrade, set error_flag for email and add error to 
#     email body
if grep -q "E: \|W: " "$log_file" ; then
	error_flag=1
	email_body+=" - System update and upgrade\n"
fi


# --------------- #
# Database Backup #
# --------------- #

# Set default rollovers for scheduled backups if not filled out in 
#     terminator.conf
[[ -z "$daily_backup_rollover" ]] && daily_backup_rollover=7
[[ -z "$weekly_backup_rollover" ]] && weekly_backup_rollover=4
[[ -z "$monthly_backup_rollover" ]] && monthly_backup_rollover=12
[[ -z "$yearly_backup_rollover" ]] && yearly_backup_rollover=5

# Set default database backup directory to current location if not set in
#     terminator.conf
[[ -z "$local_host_backup_dir" ]] && local_host_backup_dir="$(pwd)"

# Checks for db credentials in terminator.conf
# Returns false if either db_user or db_pass is not set (no db to backup)
db_backup_requested() {
	if [[ -z "$local_host_db_user" ]] || [[ -z "$local_host_db_pass" ]] ; then
		return 1
	fi

	return 0
}

# Creates the database backup directories from an array listing the desired 
#     directories
# param Dir $1 -- parent directory to contain backups
# param Array $2 -- array of backups directories
## Ex: create_db_backup_dirs ("dir1" "dir2") --> ./dir1/ ./dir2/
create_db_backup_dirs() {
	local parent_dir="$1"
	
	shift
	local db_backup_dirs=("$@")

	# Create directory structure
	for dir in "${db_backup_dirs[@]}" ; do
		if ! [[ -d "$parent_dir/$dir" ]] ; then
			mkdir -p "$parent_dir/$dir"
		fi
	done
}

# Determines if previous backup was missed
# param Dir $1 -- directory storing backups for time frame
# param Date $2 -- date backup was supposed to occur on for time frame
## Ex: current_date="2016-01-01"
### missed_backup "backup/mysqldump/weekly" "2016-01-01" --> 1
### missed_backup "backup/mysqldump/weekly" "2016-01-02" --> 0
missed_backup() {
	# Backup directory
	local backup_dir="$1"

	# most recent backup date that should have occurred
	local required_backup_date=$(date -d "$2" +"%Y%m%d")

	# Check if directory is empty because date will set to current date if it 
	#     receives a null value
	if [[ "$(ls -A "$backup_dir")" ]] ; then
		# Directory filled, check date of most recent file
		local known_backup_date="$(date -d "$(ls -lFtr --full-time \
			"$backup_dir" | awk 'FNR == 2 {print $6}')" +"%Y%m%d")"
	else
		# Directory is empty, set date to nothing manually
		local known_backup_date=0
	fi
	
	# If a backup has not occurred at the required time (required time greater
	#     than last known backup time), then backup was missed
	if (( "$required_backup_date" > "$known_backup_date" )) ; then
		return 0
	fi

	return 1
}

# Schedules the weekly backup if current weekday is the same as weekday of the
#     backup_start date in terminator.conf by copying backup file to specified
#     directory
# param Date $1 -- backup_start date located in terminator.conf
# param Dir $2 -- destination directory
# param File $3 -- backup file to copy
weekly_backup() {
	local backup_start_date="$1"
	local destination_dir="$2"
	local db_backup_file="$3"

	local current_weekday="$(date +"%A")"

	local backup_start_weekday="$(date -d "$backup_start_date" +"%A")"
	local past_backup_date="$(date -d "last $backup_start_weekday" +"%F")"

	# Need to backup if last one was missed or if it's the same day of the week
	#     as program installation (backup_start)
	if missed_backup "$destination_dir" "$past_backup_date" || \
		[[ "$current_weekday" == "$backup_start_weekday" ]] ; then

		cp "$db_backup_file" "$destination_dir"
		echo "DB Info: performed weekly backup" >> "$log_file"
	fi
}

# Schedules the monthly backup if current day of the month is the same as the
#     day of the month as the backup_start date in terminator.conf by copying
#     backup file to specified directory
# param Date $1 -- backup_start date located in terminator.conf
# param Dir $2 -- destination directory
# param File $3 -- backup file to copy
monthly_backup() {
	local backup_start_date="$1"
	local destination_dir="$2"
	local db_backup_file="$3"

	local current_day_of_month="$(date +"%d")"
	local current_month="$(date +"%m")"

	# http://stackoverflow.com/questions/12381501/how-to-use-bash-to-get-the-last-day-of-each-month-for-the-current-year-without-u
	local current_month_total_days="$(date -d "$current_month/1 \
		+ 1 month - 1 day" +"%d")"

	local backup_start_day_of_month="$(date -d "$backup_start_date" +"%d")"

	# If backup date for current month is passed, look back to same month
	# If backup date for current month is not passed, look back to previous 
	#     month
	if (("$current_day_of_month" > "$backup_start_day_of_month")) ; then
		local backup_month="$current_month"
		local backup_month_year="$(date +"%Y")"
		local backup_month_total_days="$current_month_total_days"
	else
		local backup_month="$(date -d "last month" +"%m")"
		local backup_month_year="$(date -d "last month" +"%Y")"
		local backup_month_total_days="$(date -d "$current_month/1 \
			- 1 day" +"%d")"
	fi

	# If backup_start_day_of_month is greater than the total days in the past
	#     month, then the scheduled backup would have occurred on the last day
	#     of the past month
	if (("$backup_start_day_of_month" > "$backup_month_total_days")) ; then
		local past_backup_date="$(date -d "$past_month_year-$past_month-\
			$backup_month_total_days" +"%F")"
	else
		local past_backup_date="$(date -d "$backup_month_year-$backup_month-\
			$backup_start_day_of_month" +"%F")"
	fi

	# If backup_start_day_of_month is greater than the total days in the CURRENT
	#     month, then the scheduled backup day will be the last day of the 
	#     current month
	if (("$backup_start_day_of_month" > "$current_month_total_days")) ; then
		local scheduled_backup_day="$current_month_total_days"
	else
		local scheduled_backup_day="$backup_start_day_of_month"
	fi

	# Need to backup if last one was missed or if it's the same day of the month
	#     (or last day of the month, whichever comes first) as program 
	#     installation (backup_start)
	if missed_backup "$destination_dir" "$past_backup_date" || \
		[[ "$current_day_of_month" == "$scheduled_backup_day" ]] ; then

		cp "$db_backup_file" "$destination_dir"
		echo "DB Info: performed monthly backup" >> "$log_file"
	fi
}

# Schedules the yearly backup if current day of the year is the same as the day 
#     of the year as the backup_start date in terminator.conf by copying backup 
#     file to specified directory
# param Date $1 -- backup_start date located in terminator.conf
# param Dir $2 -- destination directory
# param File $3 -- backup file to copy
yearly_backup() {
	local backup_start_date="$1"
	local destination_dir="$2"
	local db_backup_file="$3"

	local current_month_day="$(date +"%m%d")"
	local backup_start_month_day="$(date -d "$backup_start" +"%m%d")"

	if (("$current_month_day" > "$backup_start_month_day")) ; then
		local past_backup_year="$(date +"%Y")"
	else
		local past_backup_year="$(date -d "last year" +"%Y")"
	fi

	local past_backup_date="$(date -d "$past_backup_year-\
		$(date -d "$backup_start" +"%m-%d")" +"%F")"
	


}

# curate_backups() {

# }

backup_db() {
	# Check for backup schedule variable
	if [[ -z "$backup_start" ]] ; then
		echo "backup_start missing"
		echo -n "DB Backup Fatal Error: no backup start date.  " >> "$log_file"
		echo "Terminating backup." >> "$log_file"
		return 1
	fi

	# Database backup directory structure list
	db_backup_dirs=(
		"backups/mysqldump/daily"
		"backups/mysqldump/weekly"
		"backups/mysqldump/monthly"
		"backups/mysqldump/yearly"
	)

	create_db_backup_dirs "$local_host_backup_dir" "${db_backup_dirs[@]}"

	# File used for backup
	db_backup_file="$local_host_backup_dir/backups/mysqldump/daily/"
	db_backup_file+="$HOSTNAME.mysqldump.$(date +"%F_%T").sql"

	# run backup
	mysqldump -u "$local_host_db_user" -p"$local_host_db_pass" --all-databases \
		1> "$db_backup_file" 2>> "$log_file"

	# fatal db backup error
	if grep -q "mysqldump: " "$log_file" ; then
		# email flags and message
		error_flag=1
		email_body+=" - Database backup\n"
		
		# remove empty db file
		rm "$db_backup_file"

		# log fatal error
		echo "DB Backup Fatal Error: terminated DB backup" >> "$log_file"
		return 1
	fi

	# compress backup
	gzip "$db_backup_file"

	# Perform timed backups if appropriate
	weekly_backup "$backup_start" \
		"$local_host_backup_dir/backups/mysqldump/weekly" "$db_backup_file.gz"
	monthly_backup "$backup_start" \
		"$local_host_backup_dir/backups/mysqldump/monthly" "$db_backup_file.gz"

	# TODO: call monthly backup

}

# Demarcate log file section
echo "# mysqldump" >> "$log_file"

# Only attempt database backup if database credentials in terminator.conf
if db_backup_requested ; then
	backup_db
else
	echo "DB Notice:  no database credentials set.  Skipping..." >> "$log_file"
fi

# End database section of log file
echo >> "$log_file"


# ------------------------- #
# Rsync with External Hosts #
# ------------------------- #



# ------------------ #
# Admin Error Emails #
# ------------------ #

# If errors and admin emails set, send email of error status
if [[ -n "$mailto" ]] && [[ "$error_flag" == 1 ]] ; then
	echo -e "$email_body" |
	mutt -e "set from=terminator@$HOSTNAME.server realname='$HOSTNAME'" \
		-s "$HOSTNAME System Maintenance Errors" \
		-a "$log_file" -- "$mailto"
fi