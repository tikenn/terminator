#!/bin/bash
##
# Terminator: backup and maintenance system for servers
# Copyright 2016 Tim Kennell Jr.
# Licensed under the MIT License (http://opensource.org/licenses/MIT)
##

# ------------ #
# System Check #
# ------------ #

# Specify path for cron job
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Variable set automagically by setup script
# Only change if absolutely necessary
install_location=~/Desktop/terminator

# Create log directory if not exists
if ! [[ -d "$install_location/log" ]] ; then
	mkdir "$install_location/log"
fi

# Set up log file
log_file="$install_location/log/$HOSTNAME.$(date +"%F_%T").log"
touch "$log_file"

# Check for terminator.conf file
if ! [[ -f "$install_location/terminator.conf" ]] ; then
	echo "# System check" >> "$log_file"
	echo "E: could not find 'terminator.conf'.  Please run 'setup'" >> \
		"$log_file"

	exit 1
fi

# Load in user configurations
. "$install_location/terminator.conf"

# Setup error traking for emails
error_flag=0
email_body="List of errors during system maintenance\n"


# Check for backup schedule variable
if [[ -z "$backup_start" ]] ; then
	echo "# System check" >> "$log_file"
	echo -n "Fatal Error: no backup start date.  " >> "$log_file"
	echo "Terminating backup." >> "$log_file"
	
	email_body+=" - backup_start variable in terminator.conf not set"
	email_errors "$email_body" "1"

	exit 1
fi


# ------------------ #
# Admin Error Emails #
# ------------------ #

# Email errors if they occur
# param String $1 -- email body to send
# param Int $2 -- error_flag indicating error (1 for error)
email_errors() {
	# If errors and admin emails set, send email of error status
	if [[ -n "$mailto" ]] && [[ "$error_flag" == 1 ]] ; then
		echo -e "$email_body" |
		mutt -e "set from=terminator@$HOSTNAME.server realname='$HOSTNAME'" \
			-s "$HOSTNAME System Maintenance Errors" \
			-a "$log_file" -- "$mailto"
	fi
}


# ----------------- #
# Automagic Updates #
# ----------------- #

# Update
# echo "updating"
echo "# aptitude update" >> "$log_file"
aptitude update &>> "$log_file"
echo >> "$log_file"

# Upgrade
# echo "upgrading"
echo "# aptitude full-upgrade" >> "$log_file"
aptitude -y full-upgrade &>> "$log_file"
echo >> "$log_file"

# Clean
# echo "cleaning"
echo "# aptitude clean" >> "$log_file"
aptitude -y clean &>> "$log_file"
echo >> "$log_file"

# If errors with update and upgrade, set error_flag for email and add error to 
#     email body
if grep -q "E: \|W: " "$log_file" ; then
	error_flag=1
	email_body+=" - System update and upgrade\n"
fi


# ----------------- #
# Backup Scheduling #
# ----------------- #

# Calculates the date that the previous weekly backup should have occurred based
#     on the terminator install date
# return Date
previous_weekly_backup_date() {
	local backup_start_weekday="$(date -d "$backup_start" +"%A")"
	local past_backup_date="$(date -d "last $backup_start_weekday" +"%F")"

	echo "$past_backup_date"
}

# Calculates the date that the previous monthly backup should have occurred
#     based on the terminator install date
# return Date
previous_monthly_backup_date() {
	local current_day_of_month="$(date +"%-d")"
	local current_month="$(date +"%-m")"

	# http://stackoverflow.com/questions/12381501/how-to-use-bash-to-get-the-last-day-of-each-month-for-the-current-year-without-u
	local current_month_total_days="$(date -d "$current_month/1 \
		+ 1 month - 1 day" +"%-d")"

	local backup_start_day_of_month="$(date -d "$backup_start" +"%-d")"

	# If backup date for current month is passed, look back to same month
	# If backup date for current month is not passed, look back to previous 
	#     month
	if (("$current_day_of_month" > "$backup_start_day_of_month")) ; then
		local backup_month="$current_month"
		local backup_month_year="$(date +"%Y")"
		local backup_month_total_days="$current_month_total_days"
	else
		local backup_month="$(date -d "last month" +"%m")"
		local backup_month_year="$(date -d "last month" +"%Y")"
		local backup_month_total_days="$(date -d "$current_month/1 \
			- 1 day" +"%d")"
	fi

	# If backup_start_day_of_month is greater than the total days in the past
	#     month, then the scheduled backup would have occurred on the last day
	#     of the past month
	if (("$backup_start_day_of_month" > "$backup_month_total_days")) ; then
		local past_backup_date="$(date -d "$past_month_year-$past_month-\
			$backup_month_total_days" +"%F")"
	else
		local past_backup_date="$(date -d "$backup_month_year-$backup_month-\
			$backup_start_day_of_month" +"%F")"
	fi

	echo "$past_backup_date"
}

# Calculates the date that the previous yearly backup should have occurred
#     based on the terminator install date
# return Date
previous_yearly_backup_date() {
	local current_month_day="$(date +"%-m%d")"
	local backup_start_month_day="$(date -d "$backup_start" +"%-m%d")"

	# If backup date for current year is passed, look back to same year
	# If backup date for current year is not passed, look back to previous 
	#     year
	if (("$current_month_day" > "$backup_start_month_day")) ; then
		local past_backup_year="$(date +"%Y")"
	else
		local past_backup_year="$(date -d "last year" +"%Y")"
	fi

	local past_backup_date="$(date -d "$past_backup_year-\
		$(date -d "$backup_start" +"%m-%d")" +"%F")"

	echo "$past_backup_date"
}

# Checks to see if the current date matches the date for a scheduled weekly 
#     backup based on backup_start in terminator.conf
weekly_backup_date_reached() {
	local current_weekday="$(date +"%A")"
	local backup_start_weekday="$(date -d "$backup_start" +"%A")"

	# Current date is scheduled for a monthly backup
	if [[ "$current_weekday" == "$backup_start_weekday" ]] ; then
		return 0
	fi

	return 1
}

# Checks to see if the current date matches the date for a scheduled monthly 
#     backup based on backup_start in terminator.conf
monthly_backup_date_reached() {
	local current_day_of_month="$(date +"%-d")"
	local current_month="$(date +"%m")"

	# http://stackoverflow.com/questions/12381501/how-to-use-bash-to-get-the-last-day-of-each-month-for-the-current-year-without-u
	local current_month_total_days="$(date -d "$current_month/1 \
		+ 1 month - 1 day" +"%-d")"

	local backup_start_day_of_month="$(date -d "$backup_start" +"%-d")"

	# If backup_start_day_of_month is greater than the total days in the CURRENT
	#     month, then the scheduled backup day will be the last day of the 
	#     current month
	if (("$backup_start_day_of_month" > "$current_month_total_days")) ; then
		local scheduled_backup_day="$current_month_total_days"
	else
		local scheduled_backup_day="$backup_start_day_of_month"
	fi

	# Current date is scheduled for a monthly backup
	if [[ "$current_day_of_month" == "$scheduled_backup_day" ]] ; then
		return 0
	fi

	# Current date is not scheduled for a monthly backup
	return 1
}

# Checks to see if the current date matches the date for a scheduled yearly 
#     backup based on backup_start in terminator.conf
yearly_backup_date_reached() {
	local current_month_day="$(date +"%-m%d")"
	local backup_start_month_day="$(date -d "$backup_start" +"%-m%d")"

	# Current date is scheduled for a yearly backup
	if [[ "$current_month_day" == "$backup_start_month_day" ]] ; then
		return 0
	fi

	# Current date is not scheduled for a yearly backup
	return 1
}


# --------------- #
# Database Backup #
# --------------- #

# Demarcate log file section
echo "# mysqldump" >> "$log_file"

# Sets a variable to a given value by passing the variable name as a string to 
#     this function followed by the value to be set if not already set
# param Var (as string) $1 -- variable name passed as string
# param String $2 -- default value to be set if variable not already set
## Ex:  set_default_rollover "new_var" "new_value" --> new_var="new_value"
set_default_rollover() {
	local var_rollover="$1"
	local default_value="$2"

	# User has set variable to number
	if [[ -n ${!var_rollover} ]] && [[ ${!var_rollover} =~ "^[0-9]+$" ]]; then
		return 0

	# User has not set variable to number
	elif [[ -n ${!var_rollover} ]] && ! [[ ${!var_rollover} =~ "^[0-9]+$" ]]
	then
		echo -n "DB Backup Notice: " >> "$log_file"
		echo -n "$var_rollover value not recognized as an integer; "\
			>> "$log_file"
		echo "setting to default of $default_value" >> "$log_file"
	fi

	# if variable not set or filled with non integer, set to default value
	eval "$var_rollover"\="$default_value"
	return 1
}

# Set default rollovers for scheduled backups if not filled out in 
#     terminator.conf and check for numbers as values
set_default_rollover "daily_db_backup_rollover" "7"
set_default_rollover "weekly_db_backup_rollover" "4"
set_default_rollover "monthly_db_backup_rollover" "12"
set_default_rollover "yearly_db_backup_rollover" "5"


# Set default database backup directory to current location if not set in
#     terminator.conf
[[ -z "$local_host_backup_dir" ]] && \
	local_host_backup_dir="$install_location/backups"

# Checks for db credentials in terminator.conf
# Returns false if either db_user or db_pass is not set (no db to backup)
db_backup_requested() {
	if [[ -z "$local_host_db_user" ]] || [[ -z "$local_host_db_pass" ]] ; then
		return 1
	fi

	return 0
}

# Creates the backup directories from an array listing the desired 
#     directories
# param Dir $1 -- parent directory to contain backups
# param Array $2 -- array of backups directories
## Ex: create_backup_dirs ("dir1" "dir2") --> ./dir1/ ./dir2/
create_backup_dirs() {
	local parent_dir="$1"
	
	shift
	local db_backup_dirs=("$@")

	# Create directory structure
	for dir in "${db_backup_dirs[@]}" ; do
		if ! [[ -d "$parent_dir/$dir" ]] ; then
			mkdir -p "$parent_dir/$dir"
		fi
	done
}

# Determines if previous backup was missed
# param Dir $1 -- directory storing backups for time frame
# param Date $2 -- date backup was supposed to occur on for time frame
## Ex: current_date="2016-01-01"
### missed_local_backup "backup/mysqldump/weekly" "2016-01-01" --> 1
### missed_local_backup "backup/mysqldump/weekly" "2016-01-02" --> 0
missed_local_backup() {
	# Backup directory
	local backup_dir="$1"

	# most recent backup date that should have occurred
	local required_backup_date=$(date -d "$2" +"%Y%m%d")

	# Check if directory is empty because date will set to current date if it 
	#     receives a null value
	if [[ "$(ls -A "$backup_dir")" ]] ; then
		# Directory filled, check date of most recent file
		local known_backup_date="$(date -d "$(ls -lFt --full-time \
			"$backup_dir" | awk 'FNR == 2 {print $6}')" +"%Y%m%d")"
	else
		# Directory is empty, set date to nothing manually
		local known_backup_date=0
	fi
	
	# If a backup has not occurred at the required time (required time greater
	#     than last known backup time), then backup was missed
	if (( "$required_backup_date" > "$known_backup_date" )) ; then
		return 0
	fi

	return 1
}

# Deletes oldest backup file in specified directory if more files are present 
#     than the listed number
# param Dir $1 -- directory storing backups to be curated
# param Int $2 -- maximum number of files in backup location
## Ex: 8 files in directory (dir.bak)
### curate_backups dir.bak 7 --> deletes oldest file in dir.bak
curate_backups() {
	backup_dir="$1"
	backup_dir_rollover="$2"

	file_count="$(ls -1 "$backup_dir" | wc -l)"

	# Remove files until only the amount in rollover exist
	while (("$file_count" > "$backup_dir_rollover")) ; do
		# Find oldest file and remove it
		oldest_file="$(ls -lFtr "$backup_dir" | awk 'FNR == 2 {print $9}')"
		
		echo "DB Backup Info: removing old file in $backup_dir . . . " \
			>> "$log_file"
		# rm -rf "$backup_dir/$oldest_file" 2>> "$log_file"
		
		# Reset count
		file_count="$(ls -1 "$backup_dir" | wc -l)"
	done
}

# Schedules the daily backup by performing mysqldump and gzipping file, errors
#     out if no access
# param String $1 -- root user for db backup
# param String $2 -- root user password for db backup
# param File $3 -- name of backup file to store backup
daily_db_backup() {
	local db_user="$1"
	local db_pass="$2"
	local db_backup_file="$3"

	# run backup
	mysqldump -u "$db_user" -p"$db_pass" --all-databases \
		1> "$db_backup_file" 2>> "$log_file"
	echo "DB Backup Info: performed daily backup" >> "$log_file"

	# fatal db backup error
	if grep -q "mysqldump: " "$log_file" ; then
		return 1
	fi

	# compress backup
	gzip "$db_backup_file"
	return 0
}

# Schedules the weekly backup if current weekday is the same as weekday of the
#     backup_start date in terminator.conf by copying backup file to specified
#     directory
# param Dir $1 -- destination directory
# param File $2 -- backup file to copy
weekly_db_backup() {
	local destination_dir="$1"
	local db_backup_file="$2"

	# Need to backup if last one was missed or if it's the same day of the week
	#     as program installation (backup_start)
	if missed_local_backup "$destination_dir" \
		"$(previous_weekly_backup_date)" \
		|| weekly_backup_date_reached ; then

		cp "$db_backup_file" "$destination_dir"
		echo "DB Backup Info: performed weekly backup" >> "$log_file"

		curate_backups "$destination_dir" "$weekly_db_backup_rollover"
	fi
}

# Schedules the monthly backup if current day of the month is the same as the
#     day of the month as the backup_start date in terminator.conf by copying
#     backup file to specified directory
# param Dir $1 -- destination directory
# param File $2 -- backup file to copy
monthly_db_backup() {
	local destination_dir="$1"
	local db_backup_file="$2"

	# Need to backup if last one was missed or if it's the same day of the month
	#     (or last day of the month, whichever comes first) as program 
	#     installation (backup_start)
	if missed_local_backup "$destination_dir" \
		"$(previous_monthly_backup_date)" \
		|| monthly_backup_date_reached ; then

		cp "$db_backup_file" "$destination_dir"
		echo "DB Backup Info: performed monthly backup" >> "$log_file"

		curate_backups "$destination_dir" "$monthly_db_backup_rollover"
	fi
}

# Schedules the yearly backup if current day of the year is the same as the day 
#     of the year as the backup_start date in terminator.conf by copying backup 
#     file to specified directory
# param Dir $1 -- destination directory
# param File $2 -- backup file to copy
yearly_db_backup() {
	local destination_dir="$1"
	local db_backup_file="$2"

	# Need to backup if last one was missed or if it's the same day of the year
	#     as program installation (backup_start)
	if missed_local_backup "$destination_dir" \
		"$(previous_yearly_backup_date )" \
		|| yearly_backup_date_reached ; then

		cp "$db_backup_file" "$destination_dir"
		echo "DB Backup Info: performed yearly backup" >> "$log_file"

		curate_backups "$destination_dir" "$yearly_db_backup_rollover"
	fi
}

# Backs up database using scheduling functions, does not accept params
backup_db() {
	# File used for backup
	db_backup_file="$local_host_backup_dir/mysqldump/daily/"
	db_backup_file+="$HOSTNAME.mysqldump.$(date +"%F_%T").sql"

	# Perform initial daily backup, and, if successful, perform other timed
	#     backups
	if daily_db_backup "$local_host_db_user" "$local_host_db_pass" \
		"$db_backup_file" ; then

		# Perform timed backups if appropriate
		weekly_db_backup "$local_host_backup_dir/mysqldump/weekly" \
			"$db_backup_file.gz"
		monthly_db_backup "$local_host_backup_dir/mysqldump/monthly" \
			"$db_backup_file.gz"
		yearly_db_backup "$local_host_backup_dir/mysqldump/yearly" \
			"$db_backup_file.gz"
	
	else
		# email flags and message
		error_flag=1
		email_body+=" - Database backup\n"
		
		# remove empty db file
		rm "$db_backup_file"

		# log fatal error
		echo "DB Backup Fatal Error: terminated DB backup" >> "$log_file"

		return 1
	fi

	return 0
}

# Only attempt database backup if database credentials in terminator.conf
if db_backup_requested ; then
	# Database backup directory structure list
	db_backup_dirs=(
		"mysqldump/daily"
		"mysqldump/weekly"
		"mysqldump/monthly"
		"mysqldump/yearly"
	)
	create_backup_dirs "$local_host_backup_dir" "${db_backup_dirs[@]}"

	backup_db

else
	echo "DB Backup Notice:  no database credentials set.  Skipping . . ." \
		>> "$log_file"
fi

# End database section of log file
echo >> "$log_file"


# -------------- #
# System Backups #
# -------------- #

echo "# System Backups" >> "$log_file"

# Sets the default scheduling for backups if not set by the user or value is 
#     not "weekly", "monthly", or "yearly"
# param Var (as string) $1 -- variable name passed as string
# param String $2 -- default value to be set if variable not already set
## Ex:  set_default_rsync_schedule "new_var" "new_value" --> new_var="new_value"
set_default_dump_schedule() {
	local dump_schedule="$1"
	local default_value="$2"

	# User set schedule variable correctly
	if [[ -n ${!dump_schedule} ]] && ( [[ ${!dump_schedule} == "weekly" ]] \
		|| [[ ${!dump_schedule} == "monthly" ]] \
		|| [[ ${!dump_schedule} == "yearly" ]] ) ; then

		return 0
	
	# User set variable incorrectly
	elif [[ -n ${!dump_schedule} ]] && ! [[ ${!dump_schedule} == "weekly" ]] \
		&& ! [[ ${!dump_schedule} == "monthly" ]] \
		&& ! [[ ${!dump_schedule} == "yearly" ]] ; then
	
		# Notify user that default value being set for remote backup schedule
		echo -n "System Backup Notice: " >> "$log_file"
		echo -n "$dump_schedule value not recognized; " >> "$log_file"
		echo "setting to default of $default_value" >> "$log_file"
	fi

	# if variable not set or set incorrectly, set to default value
	eval "$dump_schedule"\="$default_value"
	return 1
}

set_default_dump_schedule "system_backup_freq" "weekly"

# Calculates the absolute difference between two dates
# param Date $1
#param Date $2
date_diff() {
	local diff=$(( $(date -d "$1" +"%s") - $(date -d "$2" +"%s") ))
	echo $(( ${diff#-}/(3600*24) ))
}

# Cycles through backup levels 1 - 6 when provided with a date difference 
#     greater than 1
# param Int $1 -- difference between current date and previous checkpoint
# return Int
weekly_backup_cycle_level() {
	local date_difference="$1"
	local backup_level

	# prevents level 0 by simply setting to 6
	if (($date_difference % 6 == 0)) ; then
		backup_level=6

	# Cycle of 6 (total of 7 with level 0)
	else
		backup_level=$(($date_difference % 6))

	fi

	echo "$backup_level"
}

# Calculates the level of the backup that should be performed
# Levels are on a daily schedule of 0, 1, 2, 3, 4, 5, 6, 1, 2, 3... (until next 
#     level 0 backup when everything starts over)
# return Int
backup_level() {
	local backup_level
	local current_date="$(date)"
	local date_difference

	# Weekly level 0 system dumps
	if [[ "$system_backup_freq" == "weekly" ]] ; then 
		date_difference="$(date_diff "$current_date" \
			"$(previous_weekly_backup_date)")"

		if weekly_backup_date_reached ; then
			backup_level=0

		# Cycle through backup levels till next level 0
		else
			backup_level="$(weekly_backup_cycle_level "$date_difference")"
		fi

	# Monthly level 0 system dumps
	elif [[ "$system_backup_freq" == "monthly" ]] ; then
		date_difference="$(date_diff "$current_date" \
			"$(previous_monthly_backup_date)")"

		if monthly_backup_date_reached ; then
			backup_level=0

		# Cycle through backup levels till next level 0
		else
			backup_level="$(weekly_backup_cycle_level "$date_difference")"
		fi

	# Yearly level 0 system dumps
	elif [[ "$system_backup_freq" == "yearly" ]] ; then
		date_difference="$(date_diff "$current_date" \
			"$(previous_yearly_backup_date)")"

		if yearly_backup_date_reached ; then
			backup_level=0

		# Cycle through backup levels till next level 0
		else
			backup_level="$(weekly_backup_cycle_level "$date_difference")"
		fi
	fi

	# Return
	echo "$backup_level"
}

# Resets dumps by removing all files in current dump directory so that a new
#     level 0 dump can be placed inside
# Expects files to be named xxxxxxlevel_#.tar.gz or xxxxlevel_#.snar
# param Dir $1 -- directory where system dumps are stored
# param Int $2 -- level to reset dumps to (if null, removes everything)
reset_dumps() {
	local dump_dir="$1"
	local backup_level="$2"
	local file_level

	if [[ -z "$backup_level" ]] ; then
		rm -rf "$dump_dir"/*

	else
		# look through all files
		for file in $(ls "$dump_dir") ; do
			# remove everything from the file names except the number which is 
			#     the level of the backup
			file_level=${file#*level_}
			file_level=${file_level%.tar.gz*}
			file_level=${file_level%.snar}

			# remove any file with a backup level higher than backup_level
			if (("$file_level" > "$backup_level")) ; then
				rm -rf "$dump_dir/$file"
			fi
		done
	fi
}

# Determines if a level 0 backup has been missed
# param Dir $1 -- backup directory
# param File $2 -- name of file that is supposed to contain level 0 backup
# param Date $3 -- date that level 0 backup was supposed to take place
missed_level0_backup() {
	# Backup directory
	local backup_dir="$1"

	# File containing level 0 backup (allow blob expansion)
	local level0_backup="$(ls "$backup_dir/"${2} | awk 'FNR == 1 {print $1}')"

	# most recent backup date that should have occurred
	local required_backup_date=$(date -d "$3" +"%Y%m%d")

	# Check if a level 0 backup exists in the first place (allow blob expansion)
	if [[ "$(ls -A "$level0_backup")" ]] ; then
		# backup exists, get date (only need first row of ls due to ls on file)
		local known_backup_date="$(date -d "$(ls -lFt --full-time \
			"$level0_backup" \
			| awk 'FNR == 1 {print $6}')" +"%Y%m%d")"
	
	# No level 0 file exists, assume it was missed
	else
		return 0
	fi

	# If a backup has not occurred at the required time (required time greater
	#     than last known backup time), then backup was missed
	if (( "$required_backup_date" > "$known_backup_date" )) ; then
		return 0
	fi

	return 1
}

# Determines when the previous level 0 backup date should have been based on
#     system_backup_freq in terminator.conf
previous_level0_backup_date() {
	local previous_level0_backup_date

	# Set date when previous level 0 backup was to occur based on 
	#     terminator.conf
	if [[ "$system_backup_freq" == "weekly" ]] ; then
		previous_level0_backup_date="$(previous_weekly_backup_date)"

	elif [[ "$system_backup_freq" == "monthly" ]] ; then
		previous_level0_backup_date="$(previous_monthly_backup_date)"

	elif [[ "$system_backup_freq" == "yearly" ]] ; then
		previous_level0_backup_date="$(previous_yearly_backup_date)"

	fi

	echo "$previous_level0_backup_date"
}

# Creates and names appropriate snar file based on backup_level and previous 
#     one present
# param Int $1 -- current backup level
# param Dir $2 -- directory of previous snar files from past backups
# param Dir $3 -- temporary directory to store snar till backup finalized
# return String -- name of snar file created
create_snar_file() {
	local backup_level="$1"
	local systemdump_dir="$2"
	local local_host_backup_dir="$3"

	local snar_file="$HOSTNAME.systemdump.level_$backup_level.snar"
	local level0_snar_file="$HOSTNAME.systemdump.level_0.snar"
	local newest_snar="$(ls -t "$systemdump_dir/"*.snar \
			| awk 'FNR == 1 {print $1}')"

	# Create snar file for backup_level being performed from most recent snar
	#     file
	# All level 1 backups should restart back from level 0 backup
	if [[ "$backup_level" == "1" ]] ; then
		cp "$systemdump_dir/$level0_snar_file" \
			"$local_host_backup_dir/$snar_file"

	# Missed backups (other than level 0, which is accounted for above) are of 
	#     no consequence becaause failed backups do not create snar files (they
	#     don't track changes) and backup will catch all changes since most 
	#     recent snar file
	elif ! [[ "$backup_level" == "0" ]] ; then
		cp "$newest_snar" "$local_host_backup_dir/$snar_file"

	fi

	# return
	echo "$local_host_backup_dir/$snar_file"
}

# Projects the system backup tar file size before actually performing backup
# Will only grab the first file in a list of files
# param File $1 -- tar file to be used for backup
# param File $2 -- snar file indicating level of backup
# param Dir $3 -- backup directory to exclude
# return Int -- backup size in bytes
projected_system_backup_size() {
	local tar_file="$1"
	local snar_file="$2"
	local systemdump_dir="$3"

	# Temporary snar file for checking backup size without using snar file that
	#     will actually be used for backup
	local temp_snar="$local_host_backup_dir/remaining_disk_space_check.snar"

	# Only copy file if exists; otherwise, let tar create it
	if [[ -f "$local_host_backup_dir/$snar_file" ]] ; then
		# Create temp snar file for checking backup disk size
		cp "$local_host_backup_dir/$snar_file" \
			"$local_host_backup_dir/remaining_disk_space_check.snar"
	fi

	# Projected backup size of tar backup
	# Note that all previous backups must be included in the incremental to
	#     prevent continually adding them to the incremental
	local backup_size="$(tar cpz \
		--listed-incremental="$temp_snar" \
		--exclude="$local_host_backup_dir/$tar_file" \
		--exclude="$systemdump_dir/*" --exclude="$systemdump_dir/*" \
		--one-file-system / | wc -c)"

	# Delete temporary snar file for checking remaining disk space for backup
	rm "$temp_snar"

	# Return
	echo "$backup_size"
}

# Checks for a backup that has already run today
# param File $1 -- tar file that would have been created this day 
#     (expects full path)
backup_level_rerun() {
	local tar_file=${1}

	# If blob expansion used, get first file
	local tar_file_fullname="$(ls ${tar_file} | awk 'FNR == 1 {print $1}')"

	# check if backup level has already been run
	if [[ -f "$tar_file_fullname" ]] \
		&& [[ "$(date -d "$(ls -lFt --full-time \
		"$tar_file_fullname" \
		| awk 'FNR == 1 {print $6}')" +"%Y%m%d")" == "$(date +"%Y%m%d")" ]]
		then

		return 0
	fi

	# backup level not already run
	return 1
}

# Function that actually performs entire system backup using tar
perform_system_backup() {
	local previous_level0_backup_date="$(previous_level0_backup_date)"
	local level0_tar_file_prefix="$HOSTNAME.systemdump.level_0.tar.gz"
	local backup_level="$(backup_level)"
	local systemdump_dir
	local remaining_disk_space
	
	# Create system backup directory
	create_backup_dirs "$local_host_backup_dir" "systemdump"
	systemdump_dir="$local_host_backup_dir/systemdump"

	# df returns disk space in kilobytes, converting to bytes for comparison
	remaining_disk_space=$(($(df "$local_host_backup_dir" \
		| awk 'FNR == 2 {print $4}') * 1000 ))

	# If last level 0 backup was missed, perform a level 0, no questions
	# Star is present to catch first tar file due to split
	if missed_level0_backup "$systemdump_dir" "$level0_tar_file_prefix*" \
		"$previous_level0_backup_date" ; then

		backup_level=0

		echo -n "System Backup Notice: previous level 0 backup missed.  " \
			>> "$log_file"
		echo "Attempting to perform level 0 backup . . ." >> "$log_file"
	fi

	# Backup files based on backup level
	local snar_file="$(create_snar_file "$backup_level" \
		"$systemdump_dir" "$local_host_backup_dir")"
	local tar_file_prefix="$HOSTNAME.systemdump.level_$backup_level.tar.gz"
	
	# projected size of whole backup file eliminating previous backup directory
	local projected_system_backup_size="$(projected_system_backup_size \
		"$tar_file_prefix" "$snar_file" "$systemdump_dir")"

	# Prevent re-running program on same day after successful backup from
	#     overwriting successful backup (would mess up level)
	if backup_level_rerun "$systemdump_dir/$tar_file_prefix*" ; then
		
		# Remove snar file created as it is not necessary
		rm "$snar_file"

		echo -n "System Backup Notice: level $backup_level already " \
			>> "$log_file"
		echo "successfully run today.  Terminating backup . . ." \
			>> "$log_file"

		return 1
	fi

	# If there is enough disk space
	if (("$remaining_disk_space" > "$projected_system_backup_size")) ; then
		# Perform system backup
		# Command from:  https://help.ubuntu.com/community/BackupYourSystem/TAR
		tar cpz --listed-incremental="$snar_file" \
			--exclude="$local_host_backup_dir/$tar_file" \
			--exclude="$systemdump_dir/*" --exclude="$systemdump_dir/*" \
			--one-file-system / 2>> "$log_file" \
			| split -d -b 1000m - "$local_host_backup_dir/$tar_file_prefix"

		# Backup was successful if no error status of previous command
		if [[ "${PIPESTATUS[0]}" == "0" ]] ; then
			# note backup level in log file
			echo "System Backup Info:  performed level $backup_level backup" \
				>> "$log_file"

			# Level 0 backups reset everything back to start
			if [[ "$backup_level" == "0" ]] ; then
				reset_dumps "$systemdump_dir"

			# Level 1 backups reset back to after level 0 for cycling
			elif [[ "$backup_level" == "1" ]] ; then
				reset_dumps "$systemdump_dir" "0"

			fi

			mv "$snar_file" "$systemdump_dir"
			mv "$local_host_backup_dir/$tar_file_prefix"* "$systemdump_dir"
		
			# successful backup
			return 0
		
		# Unsuccessful backup; delete files storing attempted backups
		else
			rm "$snar_file"
			rm "$local_host_backup_dir/$tar_file_prefix"*

		fi

	# there isn't enough disk space
	else
		echo -n "System Backup Error: not enough disk space remaining for " \
			>> "$log_file"
		echo -n "local backup.  " >> "$log_file"

		echo -n "Remaining: $(("$remaining_disk_space" / 1000000000)) GB; " \
			>> "$log_file"
		echo -n "Backup: $(("$projected_system_backup_size" / 1000000000)) GB. " \
			>> "$log_file"
		echo "Terminating backup . . ." >> "$log_file"

	fi

	# An error has occurred
	error_flag=1
	email_body+=" - System backup\n"
}

perform_system_backup

echo >> "$log_file"


# ------------------------- #
# Rsync with External Hosts #
# ------------------------- #

echo "# Remote Backups" >> "$log_file"

# Sets the default scheduling for backup to remote hosts if not set by the user 
#     or value is incorrectly entered
# param Var (as string) $1 -- variable name passed as string
# param String $2 -- default value to be set if variable not already set
## Ex:  set_default_rsync_schedule "new_var" "new_value" --> new_var="new_value"
set_default_rsync_schedule() {
	local rsync_schedule="$1"
	local default_value="$2"

	# User set schedule variable correctly
	if [[ -n ${!rsync_schedule} ]] && ( [[ ${!rsync_schedule} == "daily" ]] \
		|| [[ ${!rsync_schedule} == "weekly" ]] \
		|| [[ ${!rsync_schedule} == "monthly" ]] \
		|| [[ ${!rsync_schedule} == "yearly" ]] ) ; then

		return 0
	
	# User set variable incorrectly
	elif [[ -n ${!rsync_schedule} ]] && ! [[ ${!rsync_schedule} == "daily" ]] \
		&& ! [[ ${!rsync_schedule} == "weekly" ]] \
		&& ! [[ ${!rsync_schedule} == "monthly" ]] \
		&& ! [[ ${!rsync_schedule} == "yearly" ]] ; then
	
		# Notify user that default value being set for remote backup schedule
		echo -n "Remote Backup Notice: " >> "$log_file"
		echo -n "$rsync_schedule value not recognized; " >> "$log_file"
		echo "setting to default of $default_value" >> "$log_file"
	fi

	# if variable not set or set incorrectly, set to default value
	eval "$rsync_schedule"\="$default_value"
	return 1
}

set_default_rsync_schedule "on_site_backup_freq" "daily"
set_default_rsync_schedule "off_site_backup_freq" "monthly"

# Create placeholder file on remote host for keeping track of schedule
# param String $1 -- domain name of host
# param String $2 -- SSH port of host
# param String $3 -- backup user of host
# param String $4 -- host ssh key (no passphrase allowed)
# param String $5 -- backup directory on remote host
create_placeholder() {
	local domain="$1"
	local port="$2"
	local user="$3"
	local ssh_key="$4"
	local backup_dir="$5"

	ssh -q -F /dev/null "$user@$domain" -p "$port" \
		-i "$ssh_key" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
		-o StrictHostKeyChecking=no '
		
		# Create placeholder if not exists
		if ! [[ -f '"$backup_dir/"'placeholder ]] ; then
			echo "DO NOT REMOVE!!!!" > '"$backup_dir/"'placeholder
			echo -n "This is a placeholder file " >> '"$backup_dir/"'placeholder
			echo -n "for tracking the backup " >> '"$backup_dir/"'placeholder
			echo "schedule on this remote host." >> '"$backup_dir/"'placeholder
		fi

		# Change the date to current date for future reference
		touch -d "$(date)" '"$backup_dir/"'placeholder
	'
}

# Determines if previous remote backup was missed
# param String $1 -- domain name of host
# param String $2 -- SSH port of host
# param String $3 -- backup user of host
# param String $4 -- host ssh key (no passphrase allowed)
# param String $5 -- backup directory on remote host
# param Date $6 -- date backup was supposed to occur on for time frame
## Ex: current_date="2016-01-01"
### missed_remote_backup ... "backup/mysqldump/weekly" "2016-01-01" --> 1
### missed_remote_backup ... "backup/mysqldump/weekly" "2016-01-02" --> 0
missed_remote_backup() {
	local domain="$1"
	local port="$2"
	local user="$3"
	local ssh_key="$4"
	local backup_dir="$5"
	local required_backup_date="$(date -d "$6" +"%Y%m%d")"
	local known_backup_date

	known_backup_date=$(ssh -q -F /dev/null "$user@$domain" -p "$port" \
		-i "$ssh_key" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
		-o StrictHostKeyChecking=no '
		
		# Check if directory has placeholder file because date will set to 
		# current date if it receives a null value
		if [[ "$(ls -A '$backup_dir'/placeholder)" ]] ; then
			# Directory filled, check date of most recent file
			known_backup_date="$(date -d "$(ls -lFt --full-time \
				'$backup_dir/placeholder' | awk "FNR == 2 {print \$6}")" \
				+"%Y%m%d")"
		
		else
			# Directory is empty, set date to nothing manually
			known_backup_date=0
		fi

		echo "$known_backup_date"
	')

	# If a backup has not occurred at the required time (required time greater
	#     than last known backup time), then backup was missed
	if (( "$required_backup_date" > "$known_backup_date" )) ; then
		return 0
	fi

	return 1
}

# Checks existence of credentials for a backup host
# param String $1 -- domain name of host
# param String $2 -- SSH port of host
# param String $3 -- backup user of host
# param String $4 -- host ssh key (no passphrase allowed)
# param String $5 -- backup directory on remote host
remote_backup_requested() {
	local domain="$1"
	local port="$2"
	local user="$3"
	local ssh_key="$4"
	local backup_dir="$5"

	# Credentials not present, assuming no remote backup requested
	if ! [[ -n "$domain" ]] || ! [[ -n "$port" ]] || ! [[ -n "$user" ]] || \
		! [[ -n "$ssh_key" ]] || ! [[ -n "$backup_dir" ]] ; then

		return 1
	fi

	return 0
}

# Checks SSH key for existance and unencrypted state
# param String $1 -- "on-site" or "off-site"
# param Var (as string) $1 -- host ssh key (no passphrase allowed)
ssh_key_ok() {
	local ssh_key="$1"

	# SSH key isn't a real file
	if ! [[ -f "$ssh_key" ]] ; then
		echo "Remote Backup Error: the "$ssh_key" SSH key does not exist" \
			>> "$log_file"

		return 1

	# SSH key is encrypted and can't be used
	elif grep -q "ENCRYPTED" "$ssh_key" ; then
		error_flag=1
		email_body+=" - Remote backup\n"

		echo -n "Remote Backup Error: $ssh_key ssh key encrypted.  " \
			>> "$log_file"
		echo "Can't login to server." >> "$log_file"

		return 1
	fi

	# ssh key ok
	return 0
}

# Checks for ability to login to remote host
# param String $1 -- domain name of host
# param String $2 -- SSH port of host
# param String $3 -- backup user of host
# param String $4 -- host ssh key (no passphrase allowed)
# param String $5 -- backup directory on remote host
host_login_ok() {
	local domain="$1"
	local port="$2"
	local user="$3"
	local ssh_key="$4"

	# Remote host unable to be logged into
	if ! ssh -q -F /dev/null "$user@$domain" -p "$port" -i "$ssh_key" -o \
		IdentitiesOnly=yes -o StrictHostKeyChecking=no \
		-o StrictHostKeyChecking=no exit ; then

		error_flag=1
		email_body+=" - Remote backup\n"

		echo -n "Remote Backup Error: host $domain unable to be " \
			>> "$log_file"
		echo "reached; check host login parameters and remote server" \
			>> "$log_file"

		return 1

	fi

	# host is ok
	return 0
}

# Checks existence of credentials for a backup host
# param String $1 -- domain name of host
# param String $2 -- SSH port of host
# param String $3 -- backup user of host
# param String $4 -- host ssh key (no passphrase allowed)
# param String $5 -- backup directory on remote host
backup_dir_ok() {
	local domain="$1"
	local port="$2"
	local user="$3"
	local ssh_key="$4"
	local backup_dir="$5"

	local file_owner
	local file_permissions

	file_owner=$(ssh -q -F /dev/null "$user@$domain" -p "$port" \
		-i "$ssh_key" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no '
		
		file_owner="$(ls -alF '$backup_dir' | awk "FNR == 2 {print \$3}")"
		echo "$file_owner"
	')

	file_permissions=$(ssh -q -F /dev/null "$user@$domain" -p "$port" \
		-i "$ssh_key" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no '

		file_permissions="$(ls -alF '$backup_dir' | awk "FNR == 2 {print \$1}")"
		echo "$file_permissions"
	')

	if ! [[ "$file_owner" == "$user" ]] ; then
		error_flag=1
		email_body+=" - Remote backup\n"

		echo -n "Remote Backup Error: $backup_dir on host $domain not owned " \
			>> "$log_file"
		echo "by user listed in terminator.conf: $user" \
			>> "$log_file"

		return 1
	fi

	if ! [[ "$file_permissions" == drwx* ]] ; then
		error_flag=1
		email_body+=" - Remote backup\n"

		echo -n "Remote Backup Error: $backup_dir on host $domain does not " \
			>> "$log_file"
		echo "have at least 700 permissions or is not a directory" \
			>> "$log_file"

		return 1
	fi

	return 0
}

# Rsyncs to remote host daily
# param String $1 -- domain name of host
# param String $2 -- SSH port of host
# param String $3 -- backup user of host
# param String $4 -- host ssh key (no passphrase allowed)
# param String $5 -- backup directory on remote host
# param String $6 -- user selected schedule based on terminator.conf
daily_rsync() {
	local domain="$1"
	local port="$2"
	local user="$3"
	local ssh_key="$4"
	local backup_dir="$5"

	rsync -az --partial --delete --filter="P placeholder" -e "ssh -F /dev/null -p $port -i $ssh_key -o IdentitiesOnly=yes -o StrictHostKeyChecking=no" $local_host_backup_dir/ "$user@$domain:$backup_dir" 2>> "$log_file"

		echo -n "Remote Backup Info: performing daily remote backup to " \
			>> "$log_file"
		echo "host $domain" >> "$log_file"
}

# Rsyncs to remote host daily
# param String $1 -- domain name of host
# param String $2 -- SSH port of host
# param String $3 -- backup user of host
# param String $4 -- host ssh key (no passphrase allowed)
# param String $5 -- backup directory on remote host
# param String $6 -- user selected schedule based on terminator.conf
weekly_rsync() {
	local domain="$1"
	local port="$2"
	local user="$3"
	local ssh_key="$4"
	local backup_dir="$5"

	local current_weekday="$(date +"%A")"
	local backup_start_weekday="$(date -d "$backup_start" +"%A")"


	if missed_remote_backup "$domain" "$port" "$user" "$ssh_key" "$backup_dir" \
		"$(previous_weekly_backup_date)" \
		|| [[ "$current_weekday" == "$backup_start_weekday" ]] ; then

		rsync -az --partial --delete --filter="P placeholder" -e "ssh -F /dev/null -p $port -i $ssh_key -o IdentitiesOnly=yes -o StrictHostKeyChecking=no" $local_host_backup_dir/ "$user@$domain:$backup_dir" 2>> "$log_file"

		echo -n "Remote Backup Info: performing weekly remote backup to " \
			>> "$log_file"
		echo "host $domain" >> "$log_file"
	fi
}

# Rsyncs to remote host daily
# param String $1 -- domain name of host
# param String $2 -- SSH port of host
# param String $3 -- backup user of host
# param String $4 -- host ssh key (no passphrase allowed)
# param String $5 -- backup directory on remote host
# param String $6 -- user selected schedule based on terminator.conf
monthly_rsync() {
	local domain="$1"
	local port="$2"
	local user="$3"
	local ssh_key="$4"
	local backup_dir="$5"

	local current_day_of_month="$(date +"%d")"
	local current_month="$(date +"%m")"

	# http://stackoverflow.com/questions/12381501/how-to-use-bash-to-get-the-last-day-of-each-month-for-the-current-year-without-u
	local current_month_total_days="$(date -d "$current_month/1 \
		+ 1 month - 1 day" +"%-d")"

	local backup_start_day_of_month="$(date -d "$backup_start" +"%-d")"

	# If backup_start_day_of_month is greater than the total days in the CURRENT
	#     month, then the scheduled backup day will be the last day of the 
	#     current month
	if (("$backup_start_day_of_month" > "$current_month_total_days")) ; then
		local scheduled_backup_day="$current_month_total_days"
	else
		local scheduled_backup_day="$backup_start_day_of_month"
	fi

	# Need to backup if last one was missed or if it's the same day of the month
	#     (or last day of the month, whichever comes first) as program 
	#     installation (backup_start)
	if missed_remote_backup "$domain" "$port" "$user" "$ssh_key" "$backup_dir" \
		"$(previous_monthly_backup_date)" || \
		[[ "$current_day_of_month" == "$scheduled_backup_day" ]] ; then

		rsync -az --partial --delete --filter="P placeholder" -e "ssh -F /dev/null -p $port -i $ssh_key -o IdentitiesOnly=yes -o StrictHostKeyChecking=no" $local_host_backup_dir/ "$user@$domain:$backup_dir" 2>> "$log_file"

		echo -n "Remote Backup Info: performing monthly remote backup to " \
			>> "$log_file"
		echo "host $domain" >> "$log_file"
	fi
}

# Rsyncs to remote host daily
# param String $1 -- domain name of host
# param String $2 -- SSH port of host
# param String $3 -- backup user of host
# param String $4 -- host ssh key (no passphrase allowed)
# param String $5 -- backup directory on remote host
# param String $6 -- user selected schedule based on terminator.conf
yearly_rsync() {
	local domain="$1"
	local port="$2"
	local user="$3"
	local ssh_key="$4"
	local backup_dir="$5"

	local current_month_day="$(date +"%-m%d")"
	local backup_start_month_day="$(date -d "$backup_start" +"%-m%d")"

	# Need to backup if last one was missed or if it's the same day of the year
	#     as program installation (backup_start)
	if missed_remote_backup "$domain" "$port" "$user" "$ssh_key" "$backup_dir" \
		"$(previous_yearly_backup_date )" || \
		(("$current_month_day" == "$backup_start_month_day")) ; then

		rsync -az --partial --delete --filter="P placeholder" -e "ssh -F /dev/null -p $port -i $ssh_key -o IdentitiesOnly=yes -o StrictHostKeyChecking=no" $local_host_backup_dir/ "$user@$domain:$backup_dir" 2>> "$log_file"

		echo -n "Remote Backup Info: performing yearly remote backup to " \
			>> "$log_file"
		echo "host $domain" >> "$log_file"
	fi
}

# Backups to remote hosts at user selected frequency (terminator.conf)
# param String $1 -- domain name of host
# param String $2 -- SSH port of host
# param String $3 -- backup user of host
# param String $4 -- host ssh key (no passphrase allowed)
# param String $5 -- backup directory on remote host
# param String $6 -- user selected schedule based on terminator.conf
rsync_host() {
	local domain="$1"
	local port="$2"
	local user="$3"
	local ssh_key="$4"
	local backup_dir="$5"
	local backup_schedule="$6"

	# If everything is ready for login
	if ssh_key_ok "$ssh_key" && host_login_ok "$domain" "$port" "$user" \
		"$ssh_key" && backup_dir_ok "$domain" "$port" "$user" "$ssh_key" \
		"$backup_dir" ; then

		if [[ "$backup_schedule" == "daily" ]] ; then
			daily_rsync "$domain" "$port" "$user" "$ssh_key" "$backup_dir"

		elif [[ "$backup_schedule" == "weekly" ]] ; then
			weekly_rsync "$domain" "$port" "$user" "$ssh_key" "$backup_dir"

		elif [[ "$backup_schedule" == "monthly" ]] ; then
			monthly_rsync "$domain" "$port" "$user" "$ssh_key" "$backup_dir"

		elif [[ "$backup_schedule" == "yearly" ]] ; then
			yearly_rsync "$domain" "$port" "$user" "$ssh_key" "$backup_dir"

		fi

		# Rsync failed
		if grep -q "rsync: \|rsync error: " "$log_file" ; then
			email_flag=1
			email_body+=" - Remote backup\n"
			
			return 1
		fi

		# Successful rsync with no errors
		create_placeholder "$domain" "$port" "$user" "$ssh_key" "$backup_dir"
		return 0

	fi

	# connection failed
	return 1
}

# On site host backup
if remote_backup_requested "$on_site_host_domain" "$on_site_host_port" \
	"$on_site_host_user" "$on_site_host_ssh_key" "$on_site_host_backup_dir"
then
	rsync_host "$on_site_host_domain" "$on_site_host_port" \
		"$on_site_host_user" "$on_site_host_ssh_key" \
		"$on_site_host_backup_dir" "$on_site_backup_freq"

else
	echo -n "Remote Backup Notice: no on-site host login parameters.  " \
		>> "$log_file"
	echo "Skipping . . . " >> "$log_file"

fi

# Off site host backup
if remote_backup_requested "$off_site_host_domain" "$off_site_host_port" \
	"$off_site_host_user" "$off_site_host_ssh_key" "$off_site_host_backup_dir"
then
	rsync_host "$off_site_host_domain" "$off_site_host_port" \
		"$off_site_host_user" "$off_site_host_ssh_key" \
		"$off_site_host_backup_dir" "$off_site_backup_freq"

# No external hosts
else
	echo -n "Remote Backup Notice: no off-site host login parameters.  " \
		>> "$log_file"
	echo "Skipping . . . " >> "$log_file"

fi

# Email if any errors in the program
email_errors "$email_body" "$error_flag"