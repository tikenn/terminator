#!/bin/bash
##
# Terminator: backup and maintenance system for servers
# Copyright 2016 Tim Kennell Jr.
# Licensed under the MIT License (http://opensource.org/licenses/MIT)
##

# ------------ #
# System Check #
# ------------ #

# Create log directory if not exists
if ! [[ -d log ]] ; then
	mkdir log
fi

# Set up log file
log_file=log/$HOSTNAME.$(date +"%F_%T").log
touch "$log_file"

# Check for terminator.conf file
if ! [[ -f terminator.conf ]] ; then
	echo "# System check" >> "$log_file"
	echo "E: could not find 'terminator.conf'.  Please run 'setup'" >> \
		"$log_file"

	exit 1
fi

# Load in user configurations
. ./terminator.conf

error_flag=0
email_body="List of errors during system maintenance\n"


# ----------------- #
# Automagic Updates #
# ----------------- #

# Update
# echo "updating"
echo "# aptitude update" >> "$log_file"
aptitude update &>> "$log_file"
echo >> "$log_file"

# Upgrade
# echo "upgrading"
echo "# aptitude full-upgrade" >> "$log_file"
aptitude -y full-upgrade &>> "$log_file"
echo >> "$log_file"

# Clean
# echo "cleaning"
echo "# aptitude clean" >> "$log_file"
aptitude -y clean &>> "$log_file"
echo >> "$log_file"

# If errors with update and upgrade, set error_flag for email and add error to 
#     email body
if grep -q "E: \|W: " "$log_file" ; then
	error_flag=1
	email_body+=" - System update and upgrade\n"
fi


# --------------- #
# Database Backup #
# --------------- #

# Demarcate log file section
echo "# mysqldump" >> "$log_file"

# Sets a variable to a given value by passing the variable name as a string to 
#     this function followed by the value to be set if not already set
# param Var (as string) $1 -- variable name passed as string
# param String $2 -- default value to be set if variable not already set
## Ex:  set_default_rollover "new_var" "new_value" --> new_var="new_value"
set_default_rollover() {
	local var_rollover="$1"
	local default_value="$2"

	# User has set variable to number
	if [[ -n ${!var_rollover} ]] && [[ ${!var_rollover} =~ "^[0-9]+$" ]]; then
		return 0

	# User has not set variable to number
	elif [[ -n ${!var_rollover} ]] && ! [[ ${!var_rollover} =~ "^[0-9]+$" ]]
	then
		echo -n "DB Backup Notice: " >> "$log_file"
		echo -n "$var_rollover value not recognized as an integer; "\
			>> "$log_file"
		echo "setting to default of $default_value" >> "$log_file"
	fi

	# if variable not set or filled with non integer, set to default value
	eval "$var_rollover"\="$default_value"
	return 1
}

# Set default rollovers for scheduled backups if not filled out in 
#     terminator.conf and check for numbers as values
set_default_rollover "daily_backup_rollover" "7"
set_default_rollover "weekly_backup_rollover" "4"
set_default_rollover "monthly_backup_rollover" "12"
set_default_rollover "yearly_backup_rollover" "5"


# Set default database backup directory to current location if not set in
#     terminator.conf
[[ -z "$local_host_backup_dir" ]] && local_host_backup_dir="$(pwd)"

# Checks for db credentials in terminator.conf
# Returns false if either db_user or db_pass is not set (no db to backup)
db_backup_requested() {
	if [[ -z "$local_host_db_user" ]] || [[ -z "$local_host_db_pass" ]] ; then
		return 1
	fi

	return 0
}

# Creates the database backup directories from an array listing the desired 
#     directories
# param Dir $1 -- parent directory to contain backups
# param Array $2 -- array of backups directories
## Ex: create_db_backup_dirs ("dir1" "dir2") --> ./dir1/ ./dir2/
create_db_backup_dirs() {
	local parent_dir="$1"
	
	shift
	local db_backup_dirs=("$@")

	# Create directory structure
	for dir in "${db_backup_dirs[@]}" ; do
		if ! [[ -d "$parent_dir/$dir" ]] ; then
			mkdir -p "$parent_dir/$dir"
		fi
	done
}

# Determines if previous backup was missed
# param Dir $1 -- directory storing backups for time frame
# param Date $2 -- date backup was supposed to occur on for time frame
## Ex: current_date="2016-01-01"
### missed_backup "backup/mysqldump/weekly" "2016-01-01" --> 1
### missed_backup "backup/mysqldump/weekly" "2016-01-02" --> 0
missed_backup() {
	# Backup directory
	local backup_dir="$1"

	# most recent backup date that should have occurred
	local required_backup_date=$(date -d "$2" +"%Y%m%d")

	# Check if directory is empty because date will set to current date if it 
	#     receives a null value
	if [[ "$(ls -A "$backup_dir")" ]] ; then
		# Directory filled, check date of most recent file
		local known_backup_date="$(date -d "$(ls -lFt --full-time \
			"$backup_dir" | awk 'FNR == 2 {print $6}')" +"%Y%m%d")"
	else
		# Directory is empty, set date to nothing manually
		local known_backup_date=0
	fi
	
	# If a backup has not occurred at the required time (required time greater
	#     than last known backup time), then backup was missed
	if (( "$required_backup_date" > "$known_backup_date" )) ; then
		return 0
	fi

	return 1
}

# Deletes oldest backup file in specified directory if more files are present 
#     than the listed number
# param Dir $1 -- directory storing backups to be curated
# param Int $2 -- maximum number of files in backup location
## Ex: 8 files in directory (dir.bak)
### curate_backups dir.bak 7 --> deletes oldest file in dir.bak
curate_backups() {
	backup_dir="$1"
	backup_dir_rollover="$2"

	file_count="$(ls -1 "$backup_dir" | wc -l)"

	# Remove files until only the amount in rollover exist
	while (("$file_count" > "$backup_dir_rollover")) ; do
		# Find oldest file and remove it
		oldest_file="$(ls -lFtr "$backup_dir" | awk 'FNR == 2 {print $9}')"
		
		echo "DB Backup Info: removing old file in $backup_dir . . . " \
			>> "$log_file"
		rm -rf "$backup_dir/$oldest_file" 2>> "$log_file"
		
		# Reset count
		file_count="$(ls -1 "$backup_dir" | wc -l)"
	done
}

# Schedules the daily backup by performing mysqldump and gzipping file, errors
#     out if no access
# param String $1 -- root user for db backup
# param String $2 -- root user password for db backup
# param File $3 -- name of backup file to store backup
daily_backup() {
	local db_user="$1"
	local db_pass="$2"
	local db_backup_file="$3"

	# run backup
	mysqldump -u "$db_user" -p"$db_pass" --all-databases \
		1> "$db_backup_file" 2>> "$log_file"
	echo "DB Backup Info: performed daily backup" >> "$log_file"

	# fatal db backup error
	if grep -q "mysqldump: " "$log_file" ; then
		return 1
	fi

	# compress backup
	gzip "$db_backup_file"
	return 0
}

# Schedules the weekly backup if current weekday is the same as weekday of the
#     backup_start date in terminator.conf by copying backup file to specified
#     directory
# param Date $1 -- backup_start date located in terminator.conf
# param Dir $2 -- destination directory
# param File $3 -- backup file to copy
weekly_backup() {
	local backup_start_date="$1"
	local destination_dir="$2"
	local db_backup_file="$3"

	local current_weekday="$(date +"%A")"

	local backup_start_weekday="$(date -d "$backup_start_date" +"%A")"
	local past_backup_date="$(date -d "last $backup_start_weekday" +"%F")"

	# Need to backup if last one was missed or if it's the same day of the week
	#     as program installation (backup_start)
	if missed_backup "$destination_dir" "$past_backup_date" || \
		[[ "$current_weekday" == "$backup_start_weekday" ]] ; then

		cp "$db_backup_file" "$destination_dir"
		echo "DB Backup Info: performed weekly backup" >> "$log_file"

		curate_backups "$destination_dir" "$weekly_backup_rollover"
	fi
}

# Schedules the monthly backup if current day of the month is the same as the
#     day of the month as the backup_start date in terminator.conf by copying
#     backup file to specified directory
# param Date $1 -- backup_start date located in terminator.conf
# param Dir $2 -- destination directory
# param File $3 -- backup file to copy
monthly_backup() {
	local backup_start_date="$1"
	local destination_dir="$2"
	local db_backup_file="$3"

	local current_day_of_month="$(date +"%d")"
	local current_month="$(date +"%m")"

	# http://stackoverflow.com/questions/12381501/how-to-use-bash-to-get-the-last-day-of-each-month-for-the-current-year-without-u
	local current_month_total_days="$(date -d "$current_month/1 \
		+ 1 month - 1 day" +"%-d")"

	local backup_start_day_of_month="$(date -d "$backup_start_date" +"%-d")"

	# If backup date for current month is passed, look back to same month
	# If backup date for current month is not passed, look back to previous 
	#     month
	if (("$current_day_of_month" > "$backup_start_day_of_month")) ; then
		local backup_month="$current_month"
		local backup_month_year="$(date +"%Y")"
		local backup_month_total_days="$current_month_total_days"
	else
		local backup_month="$(date -d "last month" +"%m")"
		local backup_month_year="$(date -d "last month" +"%Y")"
		local backup_month_total_days="$(date -d "$current_month/1 \
			- 1 day" +"%d")"
	fi

	# If backup_start_day_of_month is greater than the total days in the past
	#     month, then the scheduled backup would have occurred on the last day
	#     of the past month
	if (("$backup_start_day_of_month" > "$backup_month_total_days")) ; then
		local past_backup_date="$(date -d "$past_month_year-$past_month-\
			$backup_month_total_days" +"%F")"
	else
		local past_backup_date="$(date -d "$backup_month_year-$backup_month-\
			$backup_start_day_of_month" +"%F")"
	fi

	# If backup_start_day_of_month is greater than the total days in the CURRENT
	#     month, then the scheduled backup day will be the last day of the 
	#     current month
	if (("$backup_start_day_of_month" > "$current_month_total_days")) ; then
		local scheduled_backup_day="$current_month_total_days"
	else
		local scheduled_backup_day="$backup_start_day_of_month"
	fi

	# Need to backup if last one was missed or if it's the same day of the month
	#     (or last day of the month, whichever comes first) as program 
	#     installation (backup_start)
	if missed_backup "$destination_dir" "$past_backup_date" || \
		[[ "$current_day_of_month" == "$scheduled_backup_day" ]] ; then

		cp "$db_backup_file" "$destination_dir"
		echo "DB Backup Info: performed monthly backup" >> "$log_file"

		curate_backups "$destination_dir" "$monthly_backup_rollover"
	fi
}

# Schedules the yearly backup if current day of the year is the same as the day 
#     of the year as the backup_start date in terminator.conf by copying backup 
#     file to specified directory
# param Date $1 -- backup_start date located in terminator.conf
# param Dir $2 -- destination directory
# param File $3 -- backup file to copy
yearly_backup() {
	local backup_start_date="$1"
	local destination_dir="$2"
	local db_backup_file="$3"

	local current_month_day="$(date +"%-m%d")"
	local backup_start_month_day="$(date -d "$backup_start" +"%-m%d")"

	if (("$current_month_day" > "$backup_start_month_day")) ; then
		local past_backup_year="$(date +"%Y")"
	else
		local past_backup_year="$(date -d "last year" +"%Y")"
	fi

	local past_backup_date="$(date -d "$past_backup_year-\
		$(date -d "$backup_start" +"%m-%d")" +"%F")"
	
	# Need to backup if last one was missed or if it's the same day of the year
	#     as program installation (backup_start)
	if missed_backup "$destination_dir" "$past_backup_date" || \
		(("$current_month_day" == "$backup_start_month_day")) ; then

		cp "$db_backup_file" "$destination_dir"
		echo "DB Backup Info: performed yearly backup" >> "$log_file"

		curate_backups "$destination_dir" "$yearly_backup_rollover"
	fi

}

# Backs up database using scheduling functions, does not accept params
backup_db() {
	# Check for backup schedule variable
	if [[ -z "$backup_start" ]] ; then
		echo -n "DB Backup Fatal Error: no backup start date.  " >> "$log_file"
		echo "Terminating backup." >> "$log_file"
		
		error_flag=1
		email_body+=" - Database backup\n"

		return 1
	fi

	# File used for backup
	db_backup_file="$local_host_backup_dir/backups/mysqldump/daily/"
	db_backup_file+="$HOSTNAME.mysqldump.$(date +"%F_%T").sql"

	# Perform initial daily backup, and, if successful, perform other timed
	#     backups
	if daily_backup "$local_host_db_user" "$local_host_db_pass" \
		"$db_backup_file" ; then

		# Perform timed backups if appropriate
		weekly_backup "$backup_start" \
			"$local_host_backup_dir/backups/mysqldump/weekly" \
			"$db_backup_file.gz"
		monthly_backup "$backup_start" \
			"$local_host_backup_dir/backups/mysqldump/monthly" \
			"$db_backup_file.gz"
		yearly_backup "$backup_start" \
			"$local_host_backup_dir/backups/mysqldump/yearly" \
			"$db_backup_file.gz"
	
	else
		# email flags and message
		error_flag=1
		email_body+=" - Database backup\n"
		
		# remove empty db file
		rm "$db_backup_file"

		# log fatal error
		echo "DB Backup Fatal Error: terminated DB backup" >> "$log_file"

		return 1
	fi

	return 0
}

# Only attempt database backup if database credentials in terminator.conf
if db_backup_requested ; then
	# Database backup directory structure list
	db_backup_dirs=(
		"backups/mysqldump/daily"
		"backups/mysqldump/weekly"
		"backups/mysqldump/monthly"
		"backups/mysqldump/yearly"
	)
	create_db_backup_dirs "$local_host_backup_dir" "${db_backup_dirs[@]}"

	backup_db
else
	echo "DB Backup Notice:  no database credentials set.  Skipping..." \
		>> "$log_file"
fi

# End database section of log file
echo >> "$log_file"


# ------------------------- #
# Rsync with External Hosts #
# ------------------------- #
on_site_host_exist() {
	if [[ -n "$on_site_host_domain" ]] && [[ -n "$on_site_host_port" ]] && \
		[[ -n "$on_site_host_user" ]] && [[ -n "$on_site_host_ssh_key" ]] && \
		[[ -n "$on_site_host_backup_dir" ]] ; then

		return 0
	fi

	return 1
}

off_site_host_exist() {
	if [[ -n "$off_site_host_domain" ]] && [[ -n "$off_site_host_port" ]] && \
		[[ -n "$off_site_host_user" ]] && [[ -n "$off_site_host_ssh_key" ]] && \
		[[ -n "$off_site_host_backup_dir" ]] ; then

		return 0
	fi

	return 1
}


# ------------------ #
# Admin Error Emails #
# ------------------ #

# If errors and admin emails set, send email of error status
if [[ -n "$mailto" ]] && [[ "$error_flag" == 1 ]] ; then
	echo -e "$email_body" |
	mutt -e "set from=terminator@$HOSTNAME.server realname='$HOSTNAME'" \
		-s "$HOSTNAME System Maintenance Errors" \
		-a "$log_file" -- "$mailto"
fi